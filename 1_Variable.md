# Ch4_Variable

> **참고한 교재**  
> [모던 자바스크립트 Deep Dive](https://product.kyobobook.co.kr/detail/S000001766445)

<br>

## 0. 변수와 식별자

![식별자](image/%EC%8B%9D%EB%B3%84%EC%9E%90.png)

### 변수

- 메모리 공간 자체
- 식별자
- 값의 위치를 가리키는 상징적인 이름

### 식별자

- 변수 이름
- 값이 아니라 메모리 주소를 기억

> **참고 (이후 작성할 내용)**
>
> - **변수 이름을 비롯한 모든 식별자는 실행 컨텍스트에 등록됨**
> - **실행 컨텍스트**  
>   자바스크립트 엔진이 소스코드를 평가하고 실행하기 위해 필요한 환경을 제공하고 코드의 실행 결과를 실제로 관리하는 영역
>
> - **자바스크립트 엔진**  
>   실행 컨텍스트를 통해 식별자와 스코프를 관리
>   변수 이름과 변수 값은 컨텍스트 내에 key, value형식인 객체로 등록되어 관리

<br>

## 1. 변수 선언

- `var`, `let`, `const` 키워드를 사용해서 변수 선언
- `var` 키워드는 블록 레벨 스코프를 지원하지 않고 `함수 레벨 스코프`를 지원
  → 전역 변수가 선언되어 부작용이 발생하기도 함 (ES5 vs ES6)
- `var`의 단점을 보완하고자 ES6에 `let`, `const`를 도입

### 선언 단계

- 변수 이름 등록 (여러 개 한번에 선언 가능 -> 권장하진 않음)
- `var score;`

### 초기화 단계

- 값을 저장하기 위한 메모리 공간 확보
- undefined 값을 자동으로 할당해 초기화
  - `undefined`: 원시 타입의 값

### 변수 호이스팅

- 변수 선언문이 코드의 맨 위로 올려진 것처럼 동작하는 자바스크립트 특징

> **<span style="color:green;">var</span>의 단점**
>
> - 변수 호이스팅 시에 <span style="color:green;">변수 선언, 초기화가 같이 이루어짐 </span>
> - 변수 호이스팅이 이루어질 때, 변수에 값이 없으면 오류가 나길 원하는데 오류가 아닌 undefined가 출력되어 버림
>
> **단점 예시**
> 예를 들어 score라는 변수에 값이 할당되지 않으면 오류가 나게 하고 싶다면 var를 사용하면 안 된다.  
> var로 변수를 선언하게 되면 변수 호이스팅 시 변수 선언과 초기화가 같이 실행되어 값을 할당하지 않았어도 undefined라는 값을 가지게 된다.  
> 결국 `ReferenceError: score is not defined`가 아닌 `undefined`가 출력된다.  
> score에 값이 없으면 오류가 나길 원하는 우리의 기대에 맞지 않게 된다.

<br>

## 2. 값의 할당

변수를 선언하고 값을 할당

```javascript
var score; // 변수 선언
score = 80; // 값의 할당
```

변수 선언과 값의 할당을 한 줄로도 표현 가능

```javascript
var score = 80; // 변수 선언과 값의 할당
```

> ⭐ **변수 선언과 값의 할당의 실행 시점이 다름**
>
> - 변수 선언은 **런타임 이전**에 먼저 실행
> - 값의 할당은 런타임에 실행

- 80이 할당된 score를 출력하는 코드

```javascript
console.log(score); // undefined

var score; // 1 변수 선언 (런타임 이전 실행)
score = 80; // 2 값의 할당 (런타임에 실행)

// var score = 80; // 변수 선언과 값의 할당

console.log(score); // 80
```

#### 💡undefined가 아니라 80이 출력되는 이유

- score 선언: `score = undefined` 초기화 ➡️ score에 80 할당: `score = 80`
- `undefined` 값은 지워지지 않고 새로운 메모리 공간에 `80`을 저장

<br>

#### 값의 할당과 변수 선언의 순서를 바꾸면?

> ```javascript
> console.log(score); // undefined
> score = 80;
> var score;
> console.log(score); // 80
> ```
>
> - 첫 번째 출력으로는 score에 값이 할당되지 않아 undefined 출력
> - 두 번째는 초기화된 score 80 출력
> - **`변수 호이스팅`** 동작으로, 변수가 선언되기 전에 변수 사용 가능
> - 초기화는 올라가지 않음

<br>

## 3. 값의 재할당

```javascript
var score = 80; // 변수 선언과 값의 할당
score = 90; // 값의 재할당
```

![재할당](image/%EC%9E%AC%ED%95%A0%EB%8B%B9.png)

**변수** `var`

- 저장된 값을 버리고 새로운 값으로 버리는 재할당이 가능

**상수** `const`

- 단 한 번만 할당 가능
- 반드시 상수만을 위해 사용하지는 않음

<br>

### 가비지 콜렉터

- 애플리케이션이 할당한 메모리 공간을 주기적으로 검사하여 더 이상 사용되지 않는 메모리를 해제하는 기능
- `undefined`, `80` ➡️ 어떤 식별자도 참조하지 않는 메모리 공간 ➡️ 언제 메모리에서 해제될지 예측할 수 없지만 가비지 콜렉터에 의해 메모리에서 자동 해제됨
- 가비지 콜렉터를 통해 메모리 누수(memery leak) 방지

> - 그니까 `score = 90;`으로 변수를 재할당했기 때문에 처음 변수를 만들 때 할당된 undefined와 내가 처음에 할당한 80은 출력되지 않지만 메모리에 있긴 함
> - 근데 얘네는 이제 참조하는 식별자가 아무도 없으니까 쓸모가 없어짐
> - 그래서 가비지 콜렉터라는 친구가 그 둘을 해제(release)함
> - 이렇게 개발자가 명시적으로 메모리를 할당하고 해제할 수 없는 언어를 **매니지드 언어**라고 함
>   (C언어 같은 언매니지드 언어는 malloc(), free()같은 메모리 제어 기능을 제공함)

<br>

## 4. 식별자 네이밍 규칙

- 문자, 숫자, 언더스코어(\_), 달러 기호($) 포함 가능
- 숫자로 시작❌
- 예약어를 식별자로 사용❌
- 한글이나 일본어 식별자도 사용할 수 있지만 권장하지 않음
- 대소문자 구별
- 네이밍 컨벤션 참고하기
  - 카멜 케이스(camelCase) ➡️ 주로 변수나 함수
  - 스네이크 케이스(snake_case)
  - 파스칼 케이스(PascalCase) ➡️ 주로 생성자 함수나 클래스 이름
  - 헝가리안 케이스(typeHungarianCase)
